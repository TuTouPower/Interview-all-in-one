# 现代操作系统

## 第1章 引论

现代计算机系统由一个或多个处理器、主存、磁盘、打印机、键盘、鼠标 、 显示器、网络接口以及各种其他输入／输出设备组成。计算机安装了一层软件，称为**操作系统** ，它的任务是为用户程序提供一个抽象的计算机模型，并管理计算机资源（刚刚提到的设备）。
用户与之交互的程序，基于文本的通常称为 **shell**  （Command Line Interface, **CLI**） ，而基于图标的则称为图形用户界面（Graphical User Interface, **GUI**），它们实际上并不是操作系统的一部分，尽管这些程序使用操作系统来完成工作。

![](https://gitee.com/TuTouPower/feng-image/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE.png)

<center>操作系统所在的位置<center>

如图给出了这里所讨论的主要部件的一个简化视图。图的底部是硬件。硬件包括芯片、电路板、磁盘、键盘、显示器以及类似的设备。在硬件的顶部是软件。多数计算机有两种运行模式：内核态和用户态。软件中最基础的部分是操作系统，它运行在**内核态 （也称为管态、核心态）**。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下。在**用户态**下，只使用了机器指令中的一个子集。特别地，那些会影响机器的控制或可进行1/0（输入／输出）操作的指令 ， 在用户态中的程序里是禁止的。
用户接口程序（ shell或者GUI）处于用户态程序中的最低层次，允许用户运行其他程序，诸如Web浏览器、电子邮件阅读器或音乐播放器等。
操作系统所在的位置如图所示。它运行在裸机之上，为所有其他软件提供基础的运行环境。 内核态和用户态之间的主要区别是，如果用户不喜欢某个特定的电子邮件阅读器，他可以自由选择另一个 ， 或者自己写一个，但是不能自行写一个属于操作系统一部分的时钟中断处理程序。这个程序由硬件保护，防止用户试图对其进行修改。

## 第2章 进程与线程

### 2.3 进程间通信

进程通信有三个问题。

+ 一个进程如何把信息传递给另一个。

+ 确保两个或更多的进程在关键活动中不会出现交叉

  > 在飞机订票系统中的两个进程为不同的客户试图争夺飞机上的最后一个座位。

+ 正确的顺序（如果该顺序是有关联的话）

  > 如果进程A产生数据而进程B打印数据，那么B在打印之前必须等待，直到A已经产生一些数据。我们将从下一节开始考察所有这三个问题。

这三个问题中的后两个问题对于线程来说是同样适用的。第一个问题（即传递信息）对线程而言比较容易，因为它们共享一个地址空间（在不同地址空间需要通信的线程属于不同进程之间通信的情形）。但是另外两个问题（需要梳理清楚并保持恰当的顺序）同样适用于线程。同样的问题可用同样的方住解决。

下面开始讨论进程间通信问题，不过请记住，同样的问题和解决方能也适用于线程。

#### 2.3.1 竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为**竞争条件（ race condition）**。调试包含有竞争条件的程序是一件很头痛的事。大多数的测试运行结果都很好，但在极少数情况下会发生一些无怯解释的奇怪现象。不幸的是，多核增长带来的并行使得竞争条件越来越普遍。以下举一个竞争条件的例子。

一个假脱机打印程序。当一个进程需要打印一个文件时，它将文件名放在一个特殊的假脱机目录（ spooler directory ）下。另一个进程（打印机守护进程）则周期性地检查是否有文件需要打印，若有就打印并将该文件名从目录下删掉。

设想假脱机目录中有许多槽位，编号依次为0，1，2 ，…，每个槽位存放一个文件名。同时假设有两个共享变量 ： out，指向下一个要打印的文件； in，指向目录中下一个空闲槽位。可以把这两个变量保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻， 0号至3号槽位空（其中的文件已经打印完毕），4号至6号槽位被占用（其中存有排好队列的要打印的文件名）。几乎在同一时刻，进程A和进程B都决定将一个文件排队打印，这种情况如图所示。

![](../../../../../Work/image/现代操作系统/两个进程同时想访问共享内存.png)

<center>两个进程同时想访问共享内存

在Murphy法则（任何可能出错的地方终将出错）生效时，可能发生以下的情况。进程A读到in的值为7,将7存在一个局部变量next_free_slot中。此时发生一次时钟中断， CPU认为进程A已运行了足够长的时间，决定切换到进程B。进程B也读取m ，同样得到值为7 ，于是将7存在B的局部变量next_free_slot中。在这一时刻两个进程都认为下一个可用槽位是7 。
进程B现在继续运行，它将其文件名存在槽位7中并将m的值更新为8。然后它离开，继续执行其他操作。
最后进程A接着从上次中断的地方再次运行。它检查变量next_free_slot，发现其值为7 ，于是将打印文件名存入7号槽位，这样就把进程B存在那里的文件名覆盖掉。然后它将next_free_slot加1 ，得到值为8 ，就将8存到in中。此时，假脱机目录内部是一致的，所以打印机守护进程发现不了任何错误，但进程B却永远得不到任何打印输出。

#### 2.3.2 临界区

#### 2.3.3 忙等待的互斥
#### 2.3.4 睡眠与唤醒
#### 2.3.5 信号量
#### 2.3.6 互斥量
#### 2.3.7 管程
#### 2.3.8 消息传递
#### 2.3.9 屏障
#### 2.3.10 避免锁：读–复制–更新
### 2.4 调度
#### 2.4.1 调度简介
#### 2.4.2 批处理系统中的调度
#### 2.4.3 交互式系统中的调度
#### 2.4.4 实时系统中的调度
#### 2.4.5 策略和机制
#### 2.4.6 线程调度
### 2.5 经典的IPC问题
#### 2.5.1 哲学家就餐问题
#### 2.5.2 读者–写者问题
#### 习题
### 2.6 有关进程与线程的研究
### 2.7 小结
## 第3章 内存管理
### 3.1 无存储器抽象
### 3.2 一种存储器抽象：地址空间
#### 3.2.1 地址空间的概念
#### 3.2.2 交换技术
#### 3.2.3 空闲内存管理
### 3.3 虚拟内存
#### 3.3.1 分页
#### 3.3.2 页表
#### 3.3.3 加速分页过程
#### 3.3.4 针对大内存的页表
### 3.4 页面置换算法
#### 3.4.1 最优页面置换算法
#### 3.4.2 最近未使用页面置换算法
#### 3.4.3 先进先出页面置换算法
#### 3.4.4 第二次机会页面置换算法
#### 3.4.5 时钟页面置换算法
#### 3.4.6 最近最少使用页面置换算法
#### 3.4.7 用软件模拟LRU
#### 3.4.8 工作集页面置换算法
#### 3.4.9 工作集时钟页面置换算法
#### 3.4.10 页面置换算法小结
### 3.5 分页系统中的设计问题
#### 3.5.1 局部分配策略与全局分配策略
#### 3.5.2 负载控制
#### 3.5.3 页面大小
#### 3.5.4 分离的指令空间和数据空间
#### 3.5.5 共享页面
#### 3.5.6 共享库
#### 3.5.7 内存映射文件
#### 3.5.8 清除策略
#### 3.5.9 虚拟内存接口
### 3.6 有关实现的问题
#### 3.6.1 与分页有关的工作
#### 3.6.2 缺页中断处理
#### 3.6.3 指令备份
#### 3.6.4 锁定内存中的页面
#### 3.6.5 后备存储
#### 3.6.6 策略和机制的分离
### 3.7 分段
#### 3.7.1 纯分段的实现
#### 3.7.2 分段和分页结合：MULTICS
#### 3.7.3 分段和分页结合：Intel x86
#### 习题
### 3.8 有关内存管理的研究
### 3.9 小结
## 第4章 文件系统
### 4.1 文件
#### 4.1.1 文件命名
#### 4.1.2 文件结构
#### 4.1.3 文件类型
#### 4.1.4 文件访问
#### 4.1.5 文件属性
#### 4.1.6 文件操作
#### 4.1.7 使用文件系统调用的一个示例程序
### 4.2 目录
#### 4.2.1 一级目录系统
#### 4.2.2 层次目录系统
#### 4.2.3 路径名
#### 4.2.4 目录操作
### 4.3 文件系统的实现
#### 4.3.1 文件系统布局
#### 4.3.2 文件的实现
#### 4.3.3 目录的实现
#### 4.3.4 共享文件
#### 4.3.5 日志结构文件系统
#### 4.3.6 日志文件系统
#### 4.3.7 虚拟文件系统
### 4.4 文件系统管理和优化
#### 4.4.1 磁盘空间管理
#### 4.4.2 文件系统备份
#### 4.4.3 文件系统的一致性
#### 4.4.4 文件系统性能
#### 4.4.5 磁盘碎片整理
### 4.5 文件系统实例
#### 4.5.1 MS-DOS文件系统
#### 4.5.2 UNIX V7文件系统
#### 4.5.3 CD-ROM文件系统
#### 习题
### 4.6 有关文件系统的研究
### 4.7 小结
## 第5章 输入/输出
### 5.1 I/O硬件原理
#### 5.1.1 I/O设备
#### 5.1.2 设备控制器
#### 5.1.3 内存映射I/O
#### 5.1.4 直接存储器存取
#### 5.1.5 重温中断
### 5.2 I/O软件原理
#### 5.2.1 I/O软件的目标
#### 5.2.2 程序控制I/O
#### 5.2.3 中断驱动I/O
#### 5.2.4 使用DMA的I/O
### 5.3 I/O软件层次
#### 5.3.1 中断处理程序
#### 5.3.2 设备驱动程序
#### 5.3.3 与设备无关的I/O软件
#### 5.3.4 用户空间的I/O软件
### 5.4 盘
#### 5.4.1 盘的硬件
#### 5.4.2 磁盘格式化
#### 5.4.3 磁盘臂调度算法
#### 5.4.4 错误处理
#### 5.4.5 稳定存储器
### 5.5 时钟
#### 5.5.1 时钟硬件
#### 5.5.2 时钟软件
#### 5.5.3 软定时器
### 5.6 用户界面：键盘、鼠标和监视器
#### 5.6.1 输入软件
#### 5.6.2 输出软件
### 5.7 瘦客户机
### 5.8 电源管理
#### 5.8.1 硬件问题
#### 5.8.2 操作系统问题
#### 5.8.3 应用程序问题
#### 习题
### 5.9 有关输入/输出的研究
### 5.10 小结
## 第6章 死锁
### 6.1 资源
#### 6.1.1 可抢占资源和不可抢占资源
#### 6.1.2 资源获取
### 6.2 死锁简介
#### 6.2.1 资源死锁的条件
#### 6.2.2 死锁建模
### 6.3 鸵鸟算法
### 6.4 死锁检测和死锁恢复
#### 6.4.1 每种类型一个资源的死锁检测
#### 6.4.2 每种类型多个资源的死锁检测
#### 6.4.3 从死锁中恢复
### 6.5 死锁避免
#### 6.5.1 资源轨迹图
#### 6.5.2 安全状态和不安全状态
#### 6.5.3 单个资源的银行家算法
#### 6.5.4 多个资源的银行家算法
### 6.6 死锁预防
#### 6.6.1 破坏互斥条件
#### 6.6.2 破坏占有并等待条件
#### 6.6.3 破坏不可抢占条件
#### 6.6.4 破坏环路等待条件
### 6.7 其他问题
#### 6.7.1 两阶段加锁
#### 6.7.2 通信死锁
#### 6.7.3 活锁
#### 6.7.4 饥饿
#### 习题
### 6.8 有关死锁的研究
### 6.9 小结
## 第7章 虚拟化和云
### 7.1 历史
### 7.2 虚拟化的必要条件
### 7.3 第一类和第二类虚拟机管理程序
### 7.4 高效虚拟化技术
#### 7.4.1 在不支持虚拟化的平台上实现虚拟化
#### 7.4.2 虚拟化的开销
### 7.5 虚拟机管理程序是正确的微内核吗
### 7.6 内存虚拟化
### 7.7 I/O虚拟化
### 7.8 虚拟装置
### 7.9 多核CPU上的虚拟机
### 7.10 授权问题
### 7.11 云
#### 7.11.1 云即服务
#### 7.11.2 虚拟机迁移
#### 7.11.3 检查点
### 7.12 案例研究：VMware
#### 7.12.1 VMware的早期历史
#### 7.12.2 VMware Workstation
#### 7.12.3 将虚拟化引入x86的挑战
#### 7.12.4 VMware Workstation解决方案概览
#### 7.12.5 VMware Workstation的演变
#### 7.12.6 VMware的第一类虚拟机管理程序ESX Server
#### 习题
### 7.13 有关虚拟化和云的研究
## 第8章 多处理机系统
### 8.1 多处理机
#### 8.1.1 多处理机硬件
#### 8.1.2 多处理机操作系统类型
#### 8.1.3 多处理机同步
#### 8.1.4 多处理机调度
### 8.2 多计算机
#### 8.2.1 多计算机硬件
#### 8.2.2 低层通信软件
#### 8.2.3 用户层通信软件
#### 8.2.4 远程过程调用
#### 8.2.5 分布式共享存储器
#### 8.2.6 多计算机调度
#### 8.2.7 负载平衡
### 8.3 分布式系统
#### 8.3.1 网络硬件
#### 8.3.2 网络服务和协议
#### 8.3.3 基于文档的中间件
#### 8.3.4 基于文件系统的中间件
#### 8.3.5 基于对象的中间件
#### 8.3.6 基于协作的中间件
#### 习题
### 8.4 有关多处理机系统的研究
### 8.5 小结
## 第9章 安全
### 9.1 环境安全
#### 9.1.1 威胁
#### 9.1.2 入侵者
### 9.2 操作系统完全
#### 9.2.1 可信系统
#### 9.2.2 可信计算基
### 9.3 保护机制
#### 9.3.1 保护域
#### 9.3.2 访问控制列表
#### 9.3.3 权能字
### 9.4 安全系统的形式化模型
#### 9.4.1 多级安全
#### 9.4.2 隐蔽信道
### 9.5 密码学原理
#### 9.5.1 私钥加密技术
#### 9.5.2 公钥加密技术
#### 9.5.3 单向函数
#### 9.5.4 数字签名
#### 9.5.5 可信平台模块
### 9.6 认证
#### 9.6.1 使用物理识别的认证方式
#### 9.6.2 使用生物识别的认证方式
### 9.7 软件漏洞
#### 9.7.1 缓冲区溢出攻击
#### 9.7.2 格式化字符串攻击
#### 9.7.3 悬垂指针
#### 9.7.4 空指针间接引用攻击
#### 9.7.5 整数溢出攻击
#### 9.7.6 命令注入攻击
#### 9.7.7 检查时间/使用时间攻击
### 9.8 内部攻击
#### 9.8.1 逻辑炸弹
#### 9.8.2 后门陷阱
#### 9.8.3 登录欺骗
### 9.9 恶意软件
#### 9.9.1 特洛伊木马
#### 9.9.2 病毒
#### 9.9.3 蠕虫
#### 9.9.4 间谍软件
#### 9.9.5 rootkit
### 9.10 防御
#### 9.10.1 防火墙
#### 9.10.2 反病毒和抑制反病毒技术
#### 9.10.3 代码签名
#### 9.10.4 囚禁
#### 9.10.5 基于模型的入侵检测
#### 9.10.6 封装移动代码
#### 9.10.7 Java安全性
#### 习题
### 9.11 有关安全的研究
### 9.12 小结
## 第10章 实例研究1：UNIX、Linux和Android
### 10.1 UNIX与Linux的历史
#### 10.1.1 UNICS
#### 10.1.2 PDP-11 UNIX
#### 10.1.3 可移植的UNIX
#### 10.1.4 Berkeley UNIX
#### 10.1.5 标准UNIX
#### 10.1.6 MINIX
#### 10.1.7 Linux
### 10.2 Linux简介
#### 10.2.1 Linux的设计目标
#### 10.2.2 到Linux的接口
#### 10.2.3 shell
#### 10.2.4 Linux应用程序
#### 10.2.5 内核结构
### 10.3 Linux中的进程
#### 10.3.1 基本概念
#### 10.3.2 Linux中进程管理相关的系统调用
#### 10.3.3 Linux中进程与线程的实现
#### 10.3.4 Linux中的调度
#### 10.3.5 启动Linux系统
### 10.4 Linux中的内存管理
#### 10.4.1 基本概念
#### 10.4.2 Linux中的内存管理系统调用
#### 10.4.3 Linux中内存管理的实现
#### 10.4.4 Linux中的分页
### 10.5 Linux中的I/O系统
#### 10.5.1 基本概念
#### 10.5.2 网络
#### 10.5.3 Linux中的I/O系统调用
#### 10.5.4 I/O在Linux中的实现
#### 10.5.5 Linux中的模块
### 10.6 Linux文件系统
#### 10.6.1 基本概念
#### 10.6.2 Linux中的文件系统调用
#### 10.6.3 Linux文件系统的实现
#### 10.6.4 NFS：网络文件系统
### 10.7 Linux的安全性
#### 10.7.1 基本概念
#### 10.7.2 Linux中安全相关的系统调用
#### 10.7.3 Linux中的安全实现
### 10.8 Android
#### 10.8.1 Android与Google
#### 10.8.2 Android的历史
#### 10.8.3 设计目标
#### 10.8.4 Android体系结构
#### 10.8.5 Linux扩展
#### 10.8.6 Dalvik
#### 10.8.7 Binder IPC
#### 10.8.8 Android应用
#### 10.8.9 意图
#### 10.8.10 应用程序沙箱
#### 10.8.11 安全性
#### 10.8.12 进程模型
#### 习题
### 10.9 小结
## 第11章 实例研究2：Windows 8
### 11.1 Windows 8.1的历史
#### 11.1.1 20世纪80年代：MS-DOS
#### 11.1.2 20世纪90年代：基于MS-DOS的Windows
#### 11.1.3 21世纪00年代：基于NT的Windows
#### 11.1.4 Windows Vista
#### 11.1.5 21世纪10年代：现代Windows
### 11.2 Windows 编程
#### 11.2.1 原生NT应用编程接口
#### 11.2.2 Win32应用编程接口
#### 11.2.3 Windows注册表
### 11.3 系统结构
#### 11.3.1 操作系统结构
#### 11.3.2 启动Windows 506                                                          
#### 11.3.3 对象管理器的实现
#### 11.3.4 子系统、DLL和用户态服务
### 11.4 Windows中的进程和线程
#### 11.4.1 基本概念
#### 11.4.2 作业、进程、线程和纤程管理API调用
#### 11.4.3 进程和线程的实现
### 11.5 内存管理
#### 11.5.1 基本概念
#### 11.5.2 内存管理系统调用
#### 11.5.3 存储管理的实现
### 11.6 Windows的高速缓存
### 11.7 Windows的I/O
#### 11.7.1 基本概念
#### 11.7.2 I/O的API调用
#### 11.7.3 I/O实现
### 11.8 Windows NT文件系统
#### 11.8.1 基本概念
#### 11.8.2 NTFS文件系统的实现
### 11.9 Windows电源管理
### 11.10 Windows 8中的安全
#### 11.10.1 基本概念
#### 11.10.2 安全相关的API调用
#### 11.10.3 安全实现
#### 11.10.4 安全缓解技术
#### 习题
### 11.11 小结
## 第12章 操作系统设计
### 12.1 设计问题的本质
#### 12.1.1 目标
#### 12.1.2 设计操作系统为什么困难
### 12.2 接口设计
#### 12.2.1 指导原则
#### 12.2.2 范型
#### 12.2.3 系统调用接口
### 12.3 实现
#### 12.3.1 系统结构
#### 12.3.2 机制与策略
#### 12.3.3 正交性
#### 12.3.4 命名
#### 12.3.5 绑定的时机
#### 12.3.6 静态与动态结构
#### 12.3.7 自顶向下与自底向上的实现
#### 12.3.8 同步通信与异步通信
#### 12.3.9 实用技术
### 12.4 性能
#### 12.4.1 操作系统为什么运行缓慢
#### 12.4.2 什么应该优化
#### 12.4.3 空间–时间的权衡
#### 12.4.4 缓存
#### 12.4.5 线索
#### 12.4.6 利用局部性
#### 12.4.7 优化常见的情况
### 12.5 项目管理
#### 12.5.1 人月神话
#### 12.5.2 团队结构
#### 12.5.3 经验的作用
#### 12.5.4 没有银弹
### 12.6 操作系统设计的趋势
#### 12.6.1 虚拟化与云
#### 12.6.2 众核芯片
#### 12.6.3 大型地址空间操作系统
#### 12.6.4 无缝的数据访问
#### 12.6.5 电池供电的计算机
#### 12.6.6 嵌入式系统
### 12.7 小结
### 习题
## 第13章 参考书目与文献
### 13.1 进行深入阅读的建议
#### 13.1.1 引论
#### 13.1.2 进程与线程
#### 13.1.3 内存管理
#### 13.1.4 文件系统
#### 13.1.5 输入/输出
#### 13.1.6 死锁
#### 13.1.7 虚拟化和云
#### 13.1.8 多处理机系统
#### 13.1.9 安全
#### 13.1.10 实例研究1：UNIX、Linux和Android
#### 13.1.11 实例研究2：Windows 8
#### 13.1.12 操作系统设计
### 13.2 按字母顺序排序的参考文献

