# 进程

## 为什么需要进程

### 早期计算机面临的问题

冯诺依曼计算机还有一个特点是按地址访问并**顺序执行指令**。早期的计算机严格遵循这个特点，使用的是[**单道批处理**](https://baike.baidu.com/item/单道批处理系统/3979111?fr=aladdin)的操作系统，即一个只进行一个程序，由它支配系统所有资源，资源利用率和系统吞吐率极低。后来出现了[**多道程序设计技术**](https://baike.baidu.com/item/多道程序设计技术)，造就了[**多道批处理**](https://baike.baidu.com/item/多道批处理系统/3792844?fr=aladdin)的操作系统。这种操作系统在内存中同时加载多道程序，它们在系统中并发执行，共享系统中的各种资源。当其中一道程序因为要等待IO或者访问存储器等而暂停执行后，CPU就去执行其他程序。多道批处理系统提高了资源利用率和系统吞吐率。但是多道批处理系统因为程序共享系统的资源，所以程序之间相互限制，经常发生冲突。

### 进程是怎样解决这些问题的

想想上面碰到的问题，你如果是一个工程师你怎么解决。既然多道批处理系统的程序共享资源会互相限制而造成冲突。那么我们就给运行的程序套一层壳——进程。使得程序只有通过进程才能申请系统资源。**进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是[操作系统](https://baike.baidu.com/item/操作系统)结构的基础。**

既然CPU运行速度远高于存储器访问速度，那么由操作系统对每一个进程作上下文切换即进程调度。将进程加入到CPU的等待队列，按照一定的调度方式加载进程到CPU执行，如果这道进程要进行IO操作等非常耗时的举动，CPU就触发中断，让这个进程一边等着去，加紧处理下一个进程，CPU一刻都不能闲着。等IO操作完成，再把进程加载回来，继续执行。**在早期面向进程设计的计算机结构中，进程是程序的基本执行实体。**  *（在当代面向线程设计的计算机结构中，进程是线程的容器，线程是程序的基本执行实体。线程是什么后面再说）*

以上述说视角都是以CPU为中心，好像满足了CPU一切就都解决了。但进程的出现对程序也是有好处的。操作系统通过**虚拟化（ virtualizing）** CPU 来 提供这种假象。 通过让一个进程只运行一个时间片， 然后切换到其他进程， 操作系统 提供了存在多个虚拟 CPU 的假象。 这就是**时分共享（ time sharing）** CPU 技术， 允许用户运行多个并发进程。**从概念上说，每个进程拥有它自己的虚拟CPU。**  

**程序是指令、数据及其组织形式的描述，进程是程序的实体。**

## 进程的状态转移

死掉的程序只是存储器上的数据，活过来的程序就是进程。没错，进程是有生命的。

### 进程的诞生

4种主要事件会导致进程的创建 ：  

- 系统初始化（init）：启动操作系统时，通常会创建若干个进程。
  - 前台进程与后台进程 [守护进程与后台进程](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)
- 正在运行的程序执行了创建进程的系统调用（比如 fork）
  - 正在运行的进程可以发出系统调用，以便创建一个或多个新进程协助其工作。  
- 用户请求创建一个新进程。
  - 在交互式系统中，键入一个命令或者点（双）击一个图标就可以启动一个程序。这两个动作中的任何一个都会开始一个新的进程，并在其中运行所选择的程序。在基于命令行的UNIX系统中运行程序X，新的进程会从该进程接管开启它的窗口  
- 初始化一个批处理工作。
  - 用户在大型机的批处理系统中（可能是远程地）提交批处理作业。在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。  

从技术上看，在所有这些情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程可以是一个运行的用户进程、一个由键盘或鼠标启动的系统进程或者一个批处理管理进程。这个系统调用通知操作系统创建一个新进程，井且直接或间接地指定在该进程中运行的程序。

+  **fork**
  + 在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 fork。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的**内存映像**，相同的环境字符串和相同的打开文件。
+ **CreateProcess**
  + 在 Windows 中，情况正相反，一个简单的 Win32 功能调用 CreateProcess，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。
+ 地址空间
  + 在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。
  + 在UNIX中，子进程的初始地址空间是父进程的一个副本，但是这里带及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使程序正文在两者间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但这种情况下内存通过**写时复制（ copy-on-write）**共亭，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域。再次强调，可写的内存是不可以共享的。但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等。
  + 在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。

### 进程的死亡

- 正常退出(自愿的) 

  - 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 `exit` ，在 Windows 中是 `ExitProcess`。

- 错误退出(自愿的)：

  - 如果用户键入命令

    ```shell
    cc foo.c
    ```

    要编译程序 foo.c ，但是该文件井不存在，于是编译器就会退出。在给出了错误参数时，面向屏幕的交互式进程通常并不退出。相反，这些程序会弹出一个对话框，并要求用户再试一次。  

- 严重错误(非自愿的)

  - 通常是由于程序中的错误所致。例如，执行了一条非法指令、引用不存在的内存，或除数是零等。有些系统中（如UNIX ），进程可以通知操作系统，它希望自行处理某些类型的错误，在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。

- 被其他进程杀死(非自愿的)

  - 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 `TerminateProcess`（注意不是系统调用）。

### 活着的进程

进程其实很苦逼，并不是或者就能一直运行到结束，毕竟资源不够多、CPU算得不够快啊。所以活着的进程除了真正在上CPU上运行还要做一件事——等。作为一个进程，你既要等CPU处理其他进程（就绪状态），也要等资源访问（阻塞状态）。他们之间的状态转移图如图所示。

![](D:\Download\桌面\知识体系\图片\进程的三种基本状态.png)

还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。挂起分为阻塞挂起和就绪挂起。挂起状态分为阻塞挂起状态和就绪挂起状态。

### 进程的状态转移

这两种挂起状态加上前面的三种状态和创建结束两种状态，就变成了七种状态变迁，见如下图：

![](D:\Download\桌面\知识体系\图片\进程的七种状态.webp)

- 运行状态（*Runing*）：该时刻进程占用 CPU；
- 就绪状态（*Ready*）：可运行，但因为其他进程正在运行而暂停停止；
- 阻塞状态（*Blocked*）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；
- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；
- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

状态转移如下：

- *NULL -> 创建状态*：一个新进程被创建时的第一个状态；
- *创建状态 -> 就绪状态*：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- *就绪态 -> 运行状态*：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；
- *运行状态 -> 结束状态*：当进程已经运行完成或出错时，会被操作系统作结束状态处理；
- *运行状态 -> 就绪状态*：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- *运行状态 -> 阻塞状态*：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
- *阻塞状态 -> 就绪状态*：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

![](../../../../../Work/image/进程/基于进程的操作系统.png)

<center>基于进程的操作系统中最底层的是中断和调度处理，在该层之上是顺序进程</center>

在图中，操作系统的最底层是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。实际上，调度程序是一段非常短小的程序。操作系统的其他部分被简单地组织成进程的形式。不过，很少有真实的系统是以这样的理想方式构造的。

## 进程的层次结构

某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。
在UNIX中，进程和它的所有子进程以及后裔组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作。
Windows中没有进程层次的概念，所有的进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候 ， 父进程得到一个特别的令牌（称为旬柄） ，该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。在UNIX中，进程就不能剥夺其子继承的“继承权”。

## 如何控制进程

### 进程的控制结构

为了实现进程模型，操作系统维护着一张表格（一个结构数组），即**进程表**（ process table）.每个进程占用一个进程表项（进程控制块）。  操作系统用**进程控制块**（*process control block，PCB*）数据结构来描述进程的。

**PCB 是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

![](D:\Download\桌面\知识体系\图片\PCB内容.webp)

+ **进程描述信息：**
    + 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
    + 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；
    + 工作目录等等

+ **进程控制和管理信息：**
    + 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
    + 进程优先级：进程抢占 CPU 时的优先级；

+ **资源分配清单：**
    + 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

+  **CPU 相关信息：**
    + CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

### 中断

在了解进程表后，就可以对在单个（或每一个） CPU上如何维持多个顺序进程的错觉做更多的阐述。
与每一个I/O类关联的是一个称作中断向量（ interrupt vector）的位置（靠近内存底部的固定区域）。它包含中断服务程序的人口 地址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆枝，计算机随即跳转到中断向量所指示的 地址。
这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。

![](../../../../../Work/image/进程/中断发生后操作系统最底层的步骤.png)

<center>中断发生后操作系统最底层的工作步骤

### 进程的完整结构

从静态角度看，进程实体 = 进程控制块（PCB）+ 程序段 + 数据段。从动态角度看，进程是可并发运行程序在其数据集合上的运行过程。

Linux进程结构：可由四部分组成：PCB、代码段、数据段、堆栈段。

+ 进程控制块是进程存在的惟一标识，系统通过PCB的存在而感知进程的存在。
+ 代码段存放程序的可执行代码段存放程序的全局变量、常量、静态变量。
+ 堆栈段中的堆用于存放动态分配的内存变量段中的栈用于函数调用，它存放着函数的参数、函数内部定义的局部变量。
+ 系统通过PCB对进程进行管理和调度。PCB包括创建进程、执行程序、退出进程以及改变进程的优先级等。而进程中的PCB用一个名为 task struct的结构体来表示，定义在include/ linux/sched. h中，每当创建新进程时，便在内存中审请个空的 task struct组构，填入所需信息，同时，指向该结构的指针也被加入到task数组中，所有进程控制块都存储在task数组中。

### 如何组织进程

#### 链表->就绪/运行/阻塞队列

通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

那么，就绪队列和阻塞队列链表的组织形式如下图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9q2vgjxfNQq38MNmricWU9jicJtxKDqu8MiaFtvia2qJ7LVxjlsMCcRDShQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 进程表(process table)

除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。

内核负责管理维护所有进程，为了管理进程，内核在内核空间维护了一个称为进程表（Process Table）的数据结构，这个数据结构中记录了所有进程，每个进程在数据结构中都称为一个进程表项（Process Table Entry），如图。

![](D:\Download\桌面\知识体系\图片\进程表与PCB.jpg)

从图中可知，进程表中除了记录了所有进程的PID，还使用一个字段记录了所有进程的指针，指向每个进程的进程控制块（Process Control Block，PCB）。

一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。

### PCB与进程的状态转移

我们熟知了进程的状态变迁和进程的数据结构 PCB 后，再来看看进程的**创建、终止、阻塞、唤醒**的过程，这些过程也就是进程的控制。

**01 创建进程**

操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。

创建进程的过程如下：

- 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败；
- 为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；
- 初始化 PCB；
- 如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；

**02 终止进程**

进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 `kill` 掉）。

终止进程的过程如下：

- 查找需要终止的进程的 PCB；
- 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；
- 如果其还有子进程，则应将其所有子进程终止；
- 将该进程所拥有的全部资源都归还给父进程或操作系统；
- 将其从 PCB 所在队列中删除；

**03 阻塞进程**

当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。

阻塞进程的过程如下：

- 找到将要被阻塞进程标识号对应的 PCB；
- 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；
- 将该 PCB 插入的阻塞队列中去；

**04 唤醒进程**

进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。

如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。

唤醒进程的过程如下：

- 在该事件的阻塞队列中找到相应进程的 PCB；
- 将其从阻塞队列中移出，并置其状态为就绪状态；
- 把该 PCB 插入到就绪队列中，等待调度程序调度；

进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。
