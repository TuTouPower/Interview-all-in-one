# MySQL必知必会

1 高亮 		2 波浪线		3 下划线

A 箭头 		R 实线框 	J 注释框		L 红线

## MySQL 体系结构

### 数据库和实例

**数据库**：物理操作系统文件或其他形式文件类型的集合。

**实例**： 由后台线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共事。需要牢记的是，数据库实例才是真正用于操作数据库文件的。

>   从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合 ：
>
>   数据库实例是程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据查询、数据·维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。

在 MySQL 数据库中，**实例与数据库的关系**通常是一一对应的，即一个实例对应一个数据库，一个数据库对应一个实例。但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。

MySQL 被设计为一个**单进程多线程**架构的数据库，这点与 SQL Server 比较类似，但与 Oracle 多进程的架构有所不同（ Oracle 的 Windows 版本也是单进程多线程架构的〉。

MySQL 数据库实例在系统上的表现就是一个进程。

MySQL 实例启动时，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，这些参数通常定义了某种内存结构有多大等。在默认情况下， MySQL 实例会按照一定的顺序在指定的位置进行读取，用户只需通过命令 mysql--help Igrep my.cnf来寻找即可。

### MySQL 体系结构

![MySQL体系结构](https://gitee.com/TuTouPower/feng-image/raw/master/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)![]()

<center>MySQL体系结构

MySQL 由以下几部分组成：

+   连接池组件
+   管理服务和工具组件
+   SQL 接口组件
+   查询分析器组件
+   优化器组件
+   缓冲（ Cache）组件
+   插件式存储引擎
+   物理文件

MySQL 数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎 。 

>    MySQL 插件式的存储引擎架构提供了一系列标准的管理和服务支持， 这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如 SQL 分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按照自己的意愿来进行开发 。

存储引擎是基于表的，而不是数据库 。 

### MySQL 存储引擎

#### InnoDB存储引擎

InnoDB 存储引擎支持事务，其设计目标主要面向在线事务处理 COLTP）的应用。
其特点是行锁设计、支持外键，并支持类似于 Oracle 的非锁定读，即默认读取操作不会产生锁。从 MySQL 数据库 5.5.8 版本开始， InnoDB 存储引擎是默认的存储引擎。

InnoDB 存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB 存储引擎自身进行管理。从 MySQL 4.1 C 包括 4.1 ）版本开始，它可以将每个InnoDB 存储引擎的表单独存放到一个独立的 ibd 文件中。此外， InnoDB 存储引擎支持用裸设备（ row disk）用来建立其表空间。

InnoDB 通过使用多版本并发控制 CMVCC ）来获得高并发性，并且实现了 SQL标准的 4 种隔离级别，默认为 REPEATABLE 级别。同时，使用一种被称为 next-key locking 的策略来避免幻读（ phantom ）现象的产生。除此之外， InnoDB 储存引擎还提供了插入缓冲（ insert buffer）、 二次写（ double write）、

自适应晗希索引（ adaptive hash index ）、预读 C read ahead ）等高性能和高可用的功能。
对于表中数据的存储， InnoDB 存储引擎采用了聚集（ clustered）的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显式地在表定义时指定主键， InnoDB 存储引擎会为每一行生成一个 6 字节的 ROWID，并以此作为主键。

#### MylSAM 存储引擎

MyISAM 存储引擎不支持事务、表锁设计，支持全文索引，主要面向 一些 OLAP数据库应用。在 MySQL 5.5.8 版本之前 MyISAM 存储引擎是默认的存储引擎（除Windows 版本外〉。数据库系统与文件系统很大的一个不同之处在于对事务的支持，然而 MyISAM 存储引擎是不支持事务的。究其根本，这也不是很难理解。试想用户是否在所有的应用中都需要事务呢？在数据仓库中，如果没有 ETL 这些操作，只是简单的报表查询是否还需要事务的支持呢？此外， MyISAM 存储引擎的另一个与众不同的地方是它的缓冲池只缓存（ cache ）索引文件，而不缓冲数据文件，这点和大多数的数据库都非常不同。

MyISAM 存储引擎表由 MYD 和 MYI 组成， MYD 用来存放数据文件， MYI 用来存放索引文件。可以通过使用 myisampack 工具来进一步压缩数据文件，因为 myisampack工具使用赫夫曼（ Huffrnan）编码静态算法来压缩数据，因此使用 myisampack 工具压缩后的表是只读的，当然用户也可以通过 myisampack 来解压数据文件。

在 MySQL 5.0 版本之前， MyISAM 默认支持的表大小为 4GB，如果需要支持大于 4GB 的 MyISAM 表时，则需要制定 MAX_ROWS 和 AVG_ROW_LENGTH 属性。从MySQL5.0 版本开始， MyISAM 默认支持 256TB 的单表数据，这足够满足一般应用需求。

>   注意 对于 MyISAM 存储引擎表， MySQL 数据库只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他，使用 LRU 算法缓存数据的大部分数据库大不相同。此，外，在 MySQL 5.1.23 版本之前，无论是在 32 位还是 64位操作系统环境下，缓存索引的援冲区最大只能设置为 4GB。在之后的版本中， 64 位系统可以支持大于 4GB 的索引缓冲区。

#### NDB 存储引擎

2003 年， MySQLAB 公司从 Sony Ericsson 公司收购了 NDB 集群引擎。NOB 存储引擎是一个集群存储引擎，类似于 Oracle 的 RAC 集群，不过与Oracle RAC share everything 架构不同的是，其结构是 share nothing 的集群架构，因此能提供更高的可用性。 NOB 的特点是数据全部放在内存中〈从 MySQL 5.1 版本开始，可以将非索引数据放在磁盘上〉，因此主键查找（ primary key lookups ）的速度极快，并且通过添加NOB 数据存储节点（ Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。

关于 NOB 存储引擎，有一个问题值得注意，那就是 NDB 存储引擎的连接操作 ( JOIN ) 是在 MySQL 数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题， NDB 存储引擎的市场应该是非常巨大的。

#### 各存储引擎之间的比较

![不同存储引擎相关特性比较](https://gitee.com/TuTouPower/feng-image/raw/master/%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7%E6%AF%94%E8%BE%83.png)![]()

<center>不同存储引擎的特性比较

### 连接MySQL

 本节将介绍连接 MySQL 数据库的常用方式。需要理解的是，连接 MySQL 操作是
一个连接进程和 MySQL 数据库实例进行通信。从程序设计的角度来说，本质上是进程通信。如果对进程通信比较了解，可以知道常用的进程通信方式有管道、命名管道、命名字、 TCP/IP 套接字、 UNIX 域套接字。 MySQL 数据库提供的连接方式从本质上看都是上述提及的进程通信方式。

## 索引与算法

### InnoDB存储引擎索引概述

InnoDB 存储引擎支持以下几种常见的索引：

+   B＋树索引
+   全文索引
+   哈希索引

前面已经提到过， lnnoDB 存储引擎支持的哈希索引是自适应的， lnnoDB 存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。
B＋树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最为常用和最为有效的索引。 B＋树索引的构造类似于二叉树，根据键值（ Key Value ）快速找到数据。

>   注意 B＋树中的 B 不是代表二又（ binaη），而是代表平衡（balance），因为B＋树是从最早的平衡二叉树演化而来，但是 B＋树不是一个二叉树。

B＋树索引并不能找到一个给定键值的具体行。B＋树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存， 再在内存中进行查找，最后得到要在找的数据 

### B+树

B＋树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在 B＋树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。先来看一个 B＋树，其高度为 2，每页可存放 4 条记录，扇出（也n out）为 5，如图所示

![B+树](https://gitee.com/TuTouPower/feng-image/raw/master/B+%E6%A0%91.png)![]()

有记录都在叶子节点上，并且是顺序存放的，如果用户从最左边的叶子节点开始顺序遍历，可以得到所有键值的顺序排序： 5、 10、 15 、 20 、 25 、30 、 50 、 55 、 60 、 65 、 75 、 80 、 85 、 90 。

![高度为2的B+树](https://gitee.com/TuTouPower/feng-image/raw/master/%E9%AB%98%E5%BA%A6%E4%B8%BA2%E7%9A%84B+%E6%A0%91.png)![]()

### B+树索引

B＋树索引的本质就是 B＋树在数据库中的实现。但是 B＋索引在数据库中有一个特点是高扇出性，因此在数据库中， B+树的高度一般都在 2 ～ 4 层，这也就是说查报一键值的行记录时最多只需要2到4次IO ，这倒不错。因为当前一般的机械磁盘每秒至少可以做 100 次 IO, 2 ～ 4 次的 IO 意昧着查询时间只需 0.02 ～ 0.04 秒。

数据库中的 B＋树索引可以分为聚集索引（ clustered inex ）和辅助索引（ secondary index ），但是不管是聚集还是辅助的索引，其内部都是 B＋树的， llfl高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。

#### 聚集索引



