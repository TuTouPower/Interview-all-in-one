## STL容器vector的实现

### operator[ ] 与 at( )

at()函数在被调用时，会检查下标的有效性（与容器的size()比较而不是capacity()（例如vector）），若下标有效则返回对应位置的元素，否则抛出std::out_of_range异常。

operator[]()函数在被调用时，不检查下标的有效性。

c++标准不要求vector::operator[]进行下标越界检查，原因是为了效率，总是强制下标越界检查会增加程序的性能开销。

### emplace( ) 与 insert( )。

`insert`和`emplace`(C++11中引入)都可以向vector中间插入元素，但`insert`可以插入多个元素，`emplace`一次只能插入一个元素。

若都是插入一个元素的情况下，该使用哪个函数呢？当然是C++11中新引入的`emplace`，`emplace`在插入元素时，在指定位置直接构造元素，而`insert`是生成元素，再将其赋值或移动到容器中。emplace的优点是，它可以就地插入并且避免了不必要的对象复制。对于原始数据类型，我们使用哪种类型都没有关系。但是对于对象，出于效率考虑，首选使用emplace（）。

### operator= 与 assign( )

```assembly
3       int main(){
=> 0x00005555555551e9 <+0>:     endbr64 
   0x00005555555551ed <+4>:     push   %rbp
   0x00005555555551ee <+5>:     mov    %rsp,%rbp
   0x00005555555551f1 <+8>:     push   %rbx
   0x00005555555551f2 <+9>:     sub    $0x38,%rsp
   0x00005555555551f6 <+13>:    mov    %fs:0x28,%rax
   0x00005555555551ff <+22>:    mov    %rax,-0x18(%rbp)
   0x0000555555555203 <+26>:    xor    %eax,%eax

4           std::vector<int> a (3, 5);
   0x0000555555555205 <+28>:    lea    -0x35(%rbp),%rax
   0x0000555555555209 <+32>:    mov    %rax,%rdi
   0x000055555555520c <+35>:    callq  0x55555555528c <std::allocator<int>::allocator()>
   0x0000555555555211 <+40>:    movl   $0x5,-0x34(%rbp)
--Type <RET> for more, q to quit, c to continue without paging--RET
   0x0000555555555218 <+47>:    lea    -0x35(%rbp),%rcx
   0x000055555555521c <+51>:    lea    -0x34(%rbp),%rdx
   0x0000555555555220 <+55>:    lea    -0x30(%rbp),%rax
   0x0000555555555224 <+59>:    mov    $0x3,%esi
   0x0000555555555229 <+64>:    mov    %rax,%rdi
   0x000055555555522c <+67>:    callq  0x5555555552cc <std::vector<int, std::allocator<int> >::vector(unsigned long, int const&, std::allocator<int> const&)>
   0x0000555555555231 <+72>:    lea    -0x35(%rbp),%rax
   0x0000555555555235 <+76>:    mov    %rax,%rdi
   0x0000555555555238 <+79>:    callq  0x5555555552ac <std::allocator<int>::~allocator()>
   0x0000555555555242 <+89>:    lea    -0x30(%rbp),%rax
   0x0000555555555246 <+93>:    mov    %rax,%rdi
   0x0000555555555249 <+96>:    callq  0x555555555354 <std::vector<int, std::allocator<int> >::~vector()>
   0x000055555555524e <+101>:   mov    %ebx,%eax

5           return 0;
   0x000055555555523d <+84>:    mov    $0x0,%ebx

6       }
   0x0000555555555250 <+103>:   mov    -0x18(%rbp),%rsi
   0x0000555555555254 <+107>:   xor    %fs:0x28,%rsi
   0x000055555555525d <+116>:   je     0x555555555284 <main()+155>
   0x000055555555525f <+118>:   jmp    0x55555555527f <main()+150>
   0x0000555555555261 <+120>:   endbr64 
   0x0000555555555265 <+124>:   mov    %rax,%rbx
   0x0000555555555268 <+127>:   lea    -0x35(%rbp),%rax
   0x000055555555526c <+131>:   mov    %rax,%rdi
   0x000055555555526f <+134>:   callq  0x5555555552ac <std::allocator<int>::~allocator()>
   0x0000555555555274 <+139>:   mov    %rbx,%rax
   0x0000555555555277 <+142>:   mov    %rax,%rdi
   0x000055555555527a <+145>:   callq  0x5555555550f0 <_Unwind_Resume@plt>
   0x000055555555527f <+150>:   callq  0x5555555550e0 <__stack_chk_fail@plt>
   0x0000555555555284 <+155>:   add    $0x38,%rsp
   0x0000555555555288 <+159>:   pop    %rbx
   0x0000555555555289 <+160>:   pop    %rbp
   0x000055555555528a <+161>:   retq   
   0x000055555555528b:  nop
```



~~~ assembly
3       int main(){
   0x00000000000011e9 <+0>:     endbr64 
   0x00000000000011ed <+4>:     push   %rbp
   0x00000000000011ee <+5>:     mov    %rsp,%rbp
   0x00000000000011f1 <+8>:     push   %rbx
   0x00000000000011f2 <+9>:     sub    $0x38,%rsp
   0x00000000000011f6 <+13>:    mov    %fs:0x28,%rax
   0x00000000000011ff <+22>:    mov    %rax,-0x18(%rbp)
   0x0000000000001203 <+26>:    xor    %eax,%eax

4           std::vector<int> b;
   0x0000000000001205 <+28>:    lea    -0x30(%rbp),%rax
   0x0000000000001209 <+32>:    mov    %rax,%rdi
   0x000000000000120c <+35>:    callq  0x12bc <std::vector<int, std::allocator<int> >::vector()>
   0x0000000000001232 <+73>:    lea    -0x30(%rbp),%rax
   0x0000000000001236 <+77>:    mov    %rax,%rdi
   0x0000000000001239 <+80>:    callq  0x137a <std::vector<int, std::allocator<int> >::~vector()>
   0x000000000000123e <+85>:    mov    %ebx,%eax
   0x0000000000001258 <+111>:   lea    -0x30(%rbp),%rax
   0x000000000000125c <+115>:   mov    %rax,%rdi
   0x000000000000125f <+118>:   callq  0x137a <std::vector<int, std::allocator<int> >::~vector()>
   0x0000000000001264 <+123>:   mov    %rbx,%rax
   0x0000000000001267 <+126>:   mov    %rax,%rdi
   0x000000000000126a <+129>:   callq  0x10f0 <_Unwind_Resume@plt>

5           b.assign(3, 5);
   0x0000000000001211 <+40>:    movl   $0x5,-0x34(%rbp)
   0x0000000000001218 <+47>:    lea    -0x34(%rbp),%rdx
   0x000000000000121c <+51>:    lea    -0x30(%rbp),%rax
   0x0000000000001220 <+55>:    mov    $0x3,%esi
   0x0000000000001225 <+60>:    mov    %rax,%rdi
   0x0000000000001228 <+63>:    callq  0x13c2 <std::vector<int, std::allocator<int> >::assign(unsigned long, int const&)>

6           return 0;
   0x000000000000122d <+68>:    mov    $0x0,%ebx

7       }
   0x0000000000001240 <+87>:    mov    -0x18(%rbp),%rcx
   0x0000000000001244 <+91>:    xor    %fs:0x28,%rcx
   0x000000000000124d <+100>:   je     0x1274 <main()+139>
   0x000000000000124f <+102>:   jmp    0x126f <main()+134>
   0x0000000000001251 <+104>:   endbr64 
   0x0000000000001255 <+108>:   mov    %rax,%rbx
--Type <RET> for more, q to quit, c to continue without paging--RET
   0x000000000000126f <+134>:   callq  0x10e0 <__stack_chk_fail@plt>
   0x0000000000001274 <+139>:   add    $0x38,%rsp
   0x0000000000001278 <+143>:   pop    %rbx
   0x0000000000001279 <+144>:   pop    %rbp
   0x000000000000127a <+145>:   retq  
~~~